# cpp

## 基础

- 模板
    - 模板也能像函数一样可以重载。
    - 显式具体化(explicit specialization)、显式实例化(explicit instantiation)、隐式实例化统称为具体化，在同一个文件中使用同一种类型的显式实例和显式具体化将出错。

- 函数
    - ANSI C 借鉴了 C++ 中的函数原型，但为了和 C 兼容、原型是可选的，但在 C++ 中，原型是必不可少的。
    - 函数原型能帮编译器正确处理函数返回值，检查使用的参数数目、参数类型是否正确。
    - C++ 通常按值传递参数。即传递常规变量的拷贝、或数组地址的拷贝。一般需要禁止无意修改数组内容，在函数数组形参前使用 const 可以保证。
    - 将指针参数 声明为 指向 const 的指针：使用 const 使得函数能够处理 const 和非 const 实参
    - 函数参数为 结构体 时，可以为小的结构体的拷贝，也可以为结构体的地址
    - 对于 inline 内联函数，部分编译器如果认为该函数过大或该函数调用了自己(递归),就不将其作为内联函数
    - 引用 & 经常被用作函数参数，称为 按引用传递，能允许被调用的函数能够访问调用函数中的变量（C 语言只能按值传递或按指针传递），应尽可能将引用形参声明为 const

- 指针和引用的区别
    - 引用总是指向某个对象，定义引用时必须初始化(之后不可改变)；引用只是一个“别名”，给引用赋值修改的是引用所关联对象的值
    - 指针可以指向任何对象，可以修改。
    - 不能对未被初始化为适当地址的指针解除引用。

- new 出来的对象，需要手动 delete，然后再设置为 NULL
    - 只能用 delete 来释放使用 new 分配的内存；不能用 delete 来释放普通变量声明所获得的内存。
    - 手工管理内存，非常容易出错，导致“内存泄露”问题，排查非常困难。使用智能指针，避免这种问题。

- 位于函数内的变量是「局部变量」，位于函数外的变量是「全局变量」，全局变量对所有的程序文件都是可见的。
    - 使用 static 修饰局部变量、可以在函数调用之间保持局部变量的值、不需要在每次进入和离开函数时进行创建和销毁。
    - 使用 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。
    - extern 是用来在另一个文件中声明一个全局变量或函数，用于当有两个或多个文件共享相同的全局变量或函数时。

C 和 C++ 使用 & 符号来指示变量的地址，C++ 也用 & 符号来声明引用。

通常使用 vector 是最好的选择，除非你有很好的理由选择其他容器。

数组是一种数据结构，在内存中连续存储同类型的多个值。C++ 将数组名解释为其第一个元素的地址：arr == &arr[0]

浮点数能够表示小数值、非常大和非常小的值（比整型范围大），但浮点数运算速度比整数慢、且精度将下降。

如何选择数据类型？通常来说 int 被设置为对目标计算机来说最“自然”(处理起来效率最高)的长度，如果没有特殊理由，则应使用 int。
如果变量表示的值不可能为负数，如人口数、文档字数，则可以使用无符号类型，这样能够表示更大的值。
如果可能超过 int 类型的最大值，则使用 long 或 long long，便于程序移植到低位数的系统上而不出现问题。
如果节省内存很重要，则应使用 short 而不是 int，即使它们的长度一样。例如 int 数组从 16 位系统移到 32 位系统，内存占用会加倍。

cin 和 cout 都是智能对象，能根据程序上下文自动“转换类型”。例如 C 语言要打印字符串"25"和整数 25 ，需要这样：
`printf("print a string: %s\n", "25");`、`printf("print an integer: %d\n", 25);`，而 cout 能自动转换。

类之于对象 就像 类型之于变量。面向对象编程（OOP）的本质是设计并扩展自己的数据类型。

编译指令 using [namespace] 可以位于任何位置，如果在函数中、只会在本函数作用域里有效。
也可以完全不使用编译指令 using，而在需要时、直接加上命名空间前缀即可、如 `std:cout << "out sth" << std:endl;`

预处理指令 #include 来引用头文件，引用头文件相当于复制头文件的内容。
建议把所有的常量、宏、系统全局变量和函数原型写在头文件中。

C++ 可以使用 C 的头文件，C++ 头文件去掉了扩展名 h，有些 C 头文件被转换为 C++ 头文件时被重新命名，
去掉了扩展名 h，并在文件名称前面加上前缀 c (表明来自 c 语言)，例如 C++ 版本的 math.h 为 cmath。


## 泛型编程

[泛型编程、STL](http://www.cnblogs.com/youngforever/p/3251097.html)

泛型（generic）是一种允许一个值取不同数据类型（所谓多态）的技术，
强调使用这种技术的编程风格被称为泛型编程（generic programming通用编程/类属编程）。

STL（Standard Template Library 标准模板库）是泛型编程思想的实际体现和具体实现，
它是一种为泛型组件建立大型标准库的可扩展架构。STL本身，与面向对象无关，也与具体的程序设计语言无关。

STL 是泛型编程思想的产物。
STL 是最新的 C++ 标准函数库中的一个子集，这个庞大的子集占据了整个库的大约 80% 的分量。
而作为在实现 STL 过程中扮演关键角色的模板则充斥了几乎整个 C++ 标准函数库。

STL提供六大组件，彼此可以组合套用。
这六大组件的交互关系：
container（容器） 通过 allocator（配置器） 取得数据储存空间，
algorithm（算法）通过 iterator（迭代器）存取 container（容器） 内容，
functor（仿函数） 可以协助 algorithm（算法） 完成不同的策略变化，
adapter（配接器） 可以修饰或套接 functor（仿函数）。

泛型编程是一种面向算法的多态技术，STL 是它的一种具体实现。

与针对问题和数据的面向对象的方法不同，泛型编程中强调的是算法。
是一类通用的参数化算法，它们对各种数据类型和各种数据结构都能以相同的方式进行工作，从而实现源代码级的软件重用。

例如，不管（容器）是数组、队列、链表、还是堆栈，不管里面的元素（类型）是字符、整数、浮点数、还是对象，
都可以使用同样的（迭代器）方法来遍历容器内的所有元素、获取指定元素的值、添加或删除元素，
从而实现排序、检索、复制、合并等各种操作和算法。

泛型编程的通用化算法，是建立在各种抽象化基础之上的：
利用参数化模版来达到数据类型的抽象化、利用容器和迭代器来达到数据结构的抽象化、
利用分配器和适配器来达到存储分配和界面接口的抽象化。

